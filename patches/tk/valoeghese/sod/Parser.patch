--- a/tk/valoeghese/sod/Parser.java
+++ b/tk/valoeghese/sod/Parser.java
@@ -1,328 +1,324 @@
-/*
- * Decompiled with CFR 0.150.
- */
 package tk.valoeghese.sod;
 
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
+import java.io.IOException;
+import java.util.Iterator;
 import java.util.Map;
-import tk.valoeghese.sod.BaseDataSection;
-import tk.valoeghese.sod.BinaryData;
-import tk.valoeghese.sod.ByteArrayDataSection;
-import tk.valoeghese.sod.DataSection;
-import tk.valoeghese.sod.DataType;
-import tk.valoeghese.sod.DoubleArrayDataSection;
-import tk.valoeghese.sod.FloatArrayDataSection;
-import tk.valoeghese.sod.IntArrayDataSection;
-import tk.valoeghese.sod.LongArrayDataSection;
-import tk.valoeghese.sod.ShortArrayDataSection;
-import tk.valoeghese.sod.StringArrayDataSection;
+
 import tk.valoeghese.sod.exception.SODParseException;
 
 final class Parser {
-    static BinaryData parse(DataInputStream dataInputStream) {
-        BaseDataSection baseDataSection;
+    @SuppressWarnings({"deprecation", "rawtypes", "unchecked"})
+    static BinaryData parse(DataInputStream input) throws IOException, SODParseException {
+        BinaryData data = new BinaryData();
+
         DataType dataType;
-        BinaryData binaryData = new BinaryData();
-        DataType dataType2 = dataType = DataType.of(dataInputStream.readByte());
-        int n = 0;
+        DataType sectionType;
+        dataType = DataType.of(input.readByte());
+        sectionType = dataType;
+
+        BaseDataSection currentSection;
+        int arraySizeCountdown = 0;
+
         try {
-            baseDataSection = dataType.createSection();
-            binaryData.put(dataInputStream.readUTF(), baseDataSection);
+            currentSection = dataType.createSection();
             if (dataType != DataType.SECTION) {
-                n = dataInputStream.readInt();
+                arraySizeCountdown = input.readInt();
             }
-        }
-        catch (SODParseException sODParseException) {
+        } catch (SODParseException e) {
             throw new SODParseException("Data must be segregated into sections!");
         }
-        block36: while (dataInputStream.available() > 0) {
-            switch (dataType2) {
-                case BYTE_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readByte());
+
+        data.put(input.readUTF(), currentSection);
+
+        while (input.available() > 0) {
+            switch (sectionType) {
+                case BYTE_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readByte());
                     }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                    break;
+                case SHORT_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readShort());
                     }
-                }
-                case SHORT_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readShort());
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
+                    break;
+                case INT_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readInt());
                     }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                }
-                case INT_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readInt());
+                    break;
+                case LONG_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readLong());
                     }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                    break;
+                case FLOAT_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readFloat());
                     }
-                }
-                case LONG_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readLong());
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
+                    break;
+                case DOUBLE_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readDouble());
                     }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                }
-                case FLOAT_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(Float.valueOf(dataInputStream.readFloat()));
+                    break;
+                case STRING_ARRAY_SECTION:
+                    while (arraySizeCountdown --> 0) {
+                        currentSection.writeForParser(input.readUTF());
                     }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
+                    // create new section if available
+                    if (input.available() > 0) {
+                        try {
+                            dataType = DataType.of(input.readByte());
+                            sectionType = dataType;
+                            currentSection = dataType.createSection();
+                            data.put(input.readUTF(), currentSection);
+                            // set countdown
+                            if (dataType != DataType.SECTION) {
+                                arraySizeCountdown = input.readInt();
+                            }
+                        } catch (SODParseException e) {
+                            throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                        }
                     }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                    break;
+                case SECTION:
+                default:
+                    dataType = DataType.of(input.readByte());
+
+                    switch (dataType) {
+                        case BYTE:
+                            currentSection.writeForParser(input.readByte());
+                            break;
+                        case DOUBLE:
+                            currentSection.writeForParser(input.readDouble());
+                            break;
+                        case FLOAT:
+                            currentSection.writeForParser(input.readFloat());
+                            break;
+                        case INT:
+                            currentSection.writeForParser(input.readInt());
+                            break;
+                        case LONG:
+                            currentSection.writeForParser(input.readLong());
+                            break;
+                        case SHORT:
+                            currentSection.writeForParser(input.readShort());
+                            break;
+                        case STRING:
+                            currentSection.writeForParser(input.readUTF());
+                            break;
+                        default:
+                            try {
+                                currentSection = dataType.createSection();
+                                sectionType = dataType;
+                                data.put(input.readUTF(), currentSection);
+                                if (dataType != DataType.SECTION) {
+                                    arraySizeCountdown = input.readInt();
+                                }
+                            } catch (SODParseException e) {
+                                throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
+                            }
+                            break;
                     }
-                }
-                case DOUBLE_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readDouble());
-                    }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
-                    }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
-                    }
-                }
-                case STRING_ARRAY_SECTION: {
-                    while (n-- > 0) {
-                        baseDataSection.writeForParser(dataInputStream.readUTF());
-                    }
-                    if (dataInputStream.available() <= 0) continue block36;
-                    try {
-                        dataType2 = dataType = DataType.of(dataInputStream.readByte());
-                        baseDataSection = dataType.createSection();
-                        binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                        if (dataType == DataType.SECTION) continue block36;
-                        n = dataInputStream.readInt();
-                        continue block36;
-                    }
-                    catch (SODParseException sODParseException) {
-                        throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
-                    }
-                }
+                    break;
             }
-            dataType = DataType.of(dataInputStream.readByte());
-            switch (dataType) {
-                case BYTE: {
-                    baseDataSection.writeForParser(dataInputStream.readByte());
-                    continue block36;
-                }
-                case DOUBLE: {
-                    baseDataSection.writeForParser(dataInputStream.readDouble());
-                    continue block36;
-                }
-                case FLOAT: {
-                    baseDataSection.writeForParser(Float.valueOf(dataInputStream.readFloat()));
-                    continue block36;
-                }
-                case INT: {
-                    baseDataSection.writeForParser(dataInputStream.readInt());
-                    continue block36;
-                }
-                case LONG: {
-                    baseDataSection.writeForParser(dataInputStream.readLong());
-                    continue block36;
-                }
-                case SHORT: {
-                    baseDataSection.writeForParser(dataInputStream.readShort());
-                    continue block36;
-                }
-                case STRING: {
-                    baseDataSection.writeForParser(dataInputStream.readUTF());
-                    continue block36;
-                }
-            }
-            try {
-                baseDataSection = dataType.createSection();
-                dataType2 = dataType;
-                binaryData.put(dataInputStream.readUTF(), baseDataSection);
-                if (dataType == DataType.SECTION) continue;
-                n = dataInputStream.readInt();
-            }
-            catch (SODParseException sODParseException) {
-                throw new RuntimeException("This error should never be thrown! If this error occurs, the parser is not properly dealing with a most-likely-invalid data type.");
-            }
         }
-        return binaryData;
+
+        return data;
     }
 
-    static void write(BinaryData object, DataOutputStream dataOutputStream) {
-        dataOutputStream.writeLong(10976542L);
-        object = ((BinaryData)object).iterator();
-        while (object.hasNext()) {
-            Object object2 = (Map.Entry)object.next();
-            BaseDataSection baseDataSection = (BaseDataSection)object2.getValue();
-            if (baseDataSection instanceof DataSection) {
-                dataOutputStream.writeByte(DataType.SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                for (Object object3 : (DataSection)baseDataSection) {
-                    if (object3 instanceof Byte) {
-                        dataOutputStream.writeByte(DataType.BYTE.id);
-                        dataOutputStream.writeByte(((Byte)object3).byteValue());
-                        continue;
+    @SuppressWarnings("rawtypes")
+    static void write(BinaryData data, DataOutputStream dos) throws IOException {
+        dos.writeLong(0xA77D1E);
+
+        Iterator<Map.Entry<String, BaseDataSection>> sectionStream = data.iterator();
+
+        while (sectionStream.hasNext()) {
+            Map.Entry<String, BaseDataSection> entry = sectionStream.next();
+            BaseDataSection section = entry.getValue();
+
+            if (section instanceof DataSection) {
+                dos.writeByte(DataType.SECTION.id);
+                dos.writeUTF(entry.getKey());
+
+                Iterator<Object> dataStream = ((DataSection) section).iterator();
+
+                while (dataStream.hasNext()) {
+                    Object o = dataStream.next();
+
+                    if (o instanceof Byte) {
+                        dos.writeByte(DataType.BYTE.id);
+                        dos.writeByte((byte) o);
+                    } else if (o instanceof Short) {
+                        dos.writeByte(DataType.SHORT.id);
+                        dos.writeShort((short) o);
+                    } else if (o instanceof Integer) {
+                        dos.writeByte(DataType.INT.id);
+                        dos.writeInt((int) o);
+                    } else if (o instanceof Long) {
+                        dos.writeByte(DataType.LONG.id);
+                        dos.writeLong((long) o);
+                    } else if (o instanceof Float) {
+                        dos.writeByte(DataType.FLOAT.id);
+                        dos.writeFloat((float) o);
+                    } else if (o instanceof Double) {
+                        dos.writeByte(DataType.DOUBLE.id);
+                        dos.writeDouble((double) o);
+                    } else if (o instanceof String) {
+                        dos.writeByte(DataType.STRING.id);
+                        dos.writeUTF((String) o);
                     }
-                    if (object3 instanceof Short) {
-                        dataOutputStream.writeByte(DataType.SHORT.id);
-                        dataOutputStream.writeShort(((Short)object3).shortValue());
-                        continue;
-                    }
-                    if (object3 instanceof Integer) {
-                        dataOutputStream.writeByte(DataType.INT.id);
-                        dataOutputStream.writeInt((Integer)object3);
-                        continue;
-                    }
-                    if (object3 instanceof Long) {
-                        dataOutputStream.writeByte(DataType.LONG.id);
-                        dataOutputStream.writeLong((Long)object3);
-                        continue;
-                    }
-                    if (object3 instanceof Float) {
-                        dataOutputStream.writeByte(DataType.FLOAT.id);
-                        dataOutputStream.writeFloat(((Float)object3).floatValue());
-                        continue;
-                    }
-                    if (object3 instanceof Double) {
-                        dataOutputStream.writeByte(DataType.DOUBLE.id);
-                        dataOutputStream.writeDouble((Double)object3);
-                        continue;
-                    }
-                    if (!(object3 instanceof String)) continue;
-                    dataOutputStream.writeByte(DataType.STRING.id);
-                    dataOutputStream.writeUTF((String)object3);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof ByteArrayDataSection) {
-                dataOutputStream.writeByte(DataType.BYTE_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((ByteArrayDataSection)baseDataSection).size());
-                object2 = ((ByteArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    byte by = (Byte)object2.next();
-                    dataOutputStream.writeByte(by);
+            } else if (section instanceof ByteArrayDataSection) { // byte array
+                dos.writeByte(DataType.BYTE_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((ByteArrayDataSection) section).size());
+
+                for (byte b : (ByteArrayDataSection) section) {
+                    dos.writeByte(b);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof ShortArrayDataSection) {
-                dataOutputStream.writeByte(DataType.SHORT_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((ShortArrayDataSection)baseDataSection).size());
-                object2 = ((ShortArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    short s = (Short)object2.next();
-                    dataOutputStream.writeShort(s);
+            } else if (section instanceof ShortArrayDataSection) { // short array
+                dos.writeByte(DataType.SHORT_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((ShortArrayDataSection) section).size());
+
+                for (short s : (ShortArrayDataSection) section) {
+                    dos.writeShort(s);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof IntArrayDataSection) {
-                dataOutputStream.writeByte(DataType.INT_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((IntArrayDataSection)baseDataSection).size());
-                object2 = ((IntArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    int n = (Integer)object2.next();
-                    dataOutputStream.writeInt(n);
+            } else if (section instanceof IntArrayDataSection) { // int array
+                dos.writeByte(DataType.INT_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((IntArrayDataSection) section).size());
+
+                for (int i : (IntArrayDataSection) section) {
+                    dos.writeInt(i);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof LongArrayDataSection) {
-                dataOutputStream.writeByte(DataType.LONG_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((LongArrayDataSection)baseDataSection).size());
-                object2 = ((LongArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    long l = (Long)object2.next();
-                    dataOutputStream.writeLong(l);
+            } else if (section instanceof LongArrayDataSection) { // long array
+                dos.writeByte(DataType.LONG_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((LongArrayDataSection) section).size());
+
+                for (long l : (LongArrayDataSection) section) {
+                    dos.writeLong(l);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof FloatArrayDataSection) {
-                dataOutputStream.writeByte(DataType.FLOAT_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((FloatArrayDataSection)baseDataSection).size());
-                object2 = ((FloatArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    float f = ((Float)object2.next()).floatValue();
-                    dataOutputStream.writeFloat(f);
+            } else if (section instanceof FloatArrayDataSection) { // float array
+                dos.writeByte(DataType.FLOAT_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((FloatArrayDataSection) section).size());
+
+                for (float f: (FloatArrayDataSection) section) {
+                    dos.writeFloat(f);
                 }
-                continue;
-            }
-            if (baseDataSection instanceof DoubleArrayDataSection) {
-                dataOutputStream.writeByte(DataType.DOUBLE_ARRAY_SECTION.id);
-                dataOutputStream.writeUTF((String)object2.getKey());
-                dataOutputStream.writeInt(((DoubleArrayDataSection)baseDataSection).size());
-                object2 = ((DoubleArrayDataSection)baseDataSection).iterator();
-                while (object2.hasNext()) {
-                    double d = (Double)object2.next();
-                    dataOutputStream.writeDouble(d);
+            } else if (section instanceof DoubleArrayDataSection) { // double array
+                dos.writeByte(DataType.DOUBLE_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((DoubleArrayDataSection) section).size());
+
+                for (double d : (DoubleArrayDataSection) section) {
+                    dos.writeDouble(d);
                 }
-                continue;
+            } else if (section instanceof StringArrayDataSection) { // string array
+                dos.writeByte(DataType.STRING_ARRAY_SECTION.id);
+                dos.writeUTF(entry.getKey());
+                dos.writeInt(((StringArrayDataSection) section).size());
+
+                for (String s : (StringArrayDataSection) section) {
+                    dos.writeUTF(s);
+                }
             }
-            if (!(baseDataSection instanceof StringArrayDataSection)) continue;
-            dataOutputStream.writeByte(DataType.STRING_ARRAY_SECTION.id);
-            dataOutputStream.writeUTF((String)object2.getKey());
-            dataOutputStream.writeInt(((StringArrayDataSection)baseDataSection).size());
-            for (Object object3 : (StringArrayDataSection)baseDataSection) {
-                dataOutputStream.writeUTF((String)object3);
-            }
         }
     }
 }
-
