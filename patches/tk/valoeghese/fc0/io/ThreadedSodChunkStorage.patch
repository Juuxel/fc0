--- a/tk/valoeghese/fc0/io/ThreadedSodChunkStorage.java
+++ b/tk/valoeghese/fc0/io/ThreadedSodChunkStorage.java
@@ -1,19 +1,5 @@
-/*
- * Decompiled with CFR 0.150.
- * 
- * Could not load the following classes:
- *  javax.annotation.Nullable
- */
 package tk.valoeghese.fc0.io;
 
-import java.io.File;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-import java.util.Iterator;
-import java.util.Random;
-import javax.annotation.Nullable;
 import tk.valoeghese.fc0.client.Fc0;
-import tk.valoeghese.fc0.io.SaveThread;
-import tk.valoeghese.fc0.item.Item;
 import tk.valoeghese.fc0.math.Pos;
 import tk.valoeghese.fc0.world.Chunk;
@@ -21,11 +7,49 @@
 import tk.valoeghese.fc0.world.ChunkGenerator;
 import tk.valoeghese.fc0.world.ChunkView;
-import tk.valoeghese.sod.BaseDataSection;
+import tk.valoeghese.fc0.item.Item;
 import tk.valoeghese.sod.BinaryData;
 import tk.valoeghese.sod.DataSection;
 
-public final class ThreadedSodChunkStorage {
-    private final File saveDirectory;
-    private final File saveFile;
+import javax.annotation.Nullable;
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.util.Iterator;
+import java.util.Random;
+
+public class ThreadedSodChunkStorage {
+    // client specific stuff is here. will need to change on server
+    public ThreadedSodChunkStorage(String name, long seed) {
+        this.parentDir = new File("./saves/" + name);
+        this.parentDir.mkdirs();
+
+        this.saveDat = new File(this.parentDir, "save.gsod");
+
+        if (this.saveDat.exists()) {
+            BinaryData data = BinaryData.readGzipped(this.saveDat);
+            DataSection mainData = data.get("data");
+            this.seed = mainData.readLong(0);
+            Fc0.get().time = mainData.readLong(1);
+
+            DataSection playerData = data.get("player");
+            this.playerPos = new Pos(playerData.readDouble(0), playerData.readDouble(1), playerData.readDouble(2));
+            this.spawnPoint = new Pos(playerData.readDouble(3), playerData.readDouble(4), playerData.readDouble(5));
+
+            if (data.method_242("playerInventory")) {
+                DataSection playerInventoryData = data.get("playerInventory");
+                this.playerInventory = this.loadInventory(playerInventoryData);
+            } else {
+                this.playerInventory = null;
+            }
+        } else {
+            this.seed = seed;
+            this.playerPos = null;
+            this.spawnPoint = null;
+            this.playerInventory = null;
+        }
+    }
+
+    private final File parentDir;
+    private final File saveDat;
     private final long seed;
     @Nullable
@@ -33,217 +57,182 @@
     @Nullable
     public final Pos spawnPoint;
-    private static SaveThread saveThread;
-    private static final Object LOCK;
+    private static SaveThread thread;
+    private static final Object lock = new Object();
     @Nullable
     public final Item[] playerInventory;
 
-    /*
-     * Enabled aggressive block sorting
-     */
-    public ThreadedSodChunkStorage(String object, long l) {
-        this.saveDirectory = new File("./saves/" + (String)object);
-        this.saveDirectory.mkdirs();
-        this.saveFile = new File(this.saveDirectory, "save.gsod");
-        if (!this.saveFile.exists()) {
-            this.seed = l;
-            this.playerPos = null;
-            this.spawnPoint = null;
-            this.playerInventory = null;
-            return;
-        }
-        object = BinaryData.readGzipped(this.saveFile);
-        DataSection dataSection = ((BinaryData)object).get("data");
-        this.seed = dataSection.readLong(0);
-        Fc0.get().time = dataSection.readLong(1);
-        dataSection = ((BinaryData)object).get("player");
-        this.playerPos = new Pos(dataSection.readDouble(0), dataSection.readDouble(1), dataSection.readDouble(2));
-        this.spawnPoint = new Pos(dataSection.readDouble(3), dataSection.readDouble(4), dataSection.readDouble(5));
-        if (((BinaryData)object).method_242("playerInventory")) {
-            object = ((BinaryData)object).get("playerInventory");
-            this.playerInventory = ThreadedSodChunkStorage.readInventory((DataSection)object);
-            return;
-        }
-        this.playerInventory = null;
-    }
-
-    public final long getSeed() {
+    public long getSeed() {
         return this.seed;
     }
 
-    /*
-     * WARNING - Removed try catching itself - possible behaviour change.
-     */
-    public final void saveChunks(Iterator<? extends Chunk> iterator) {
-        Object object = LOCK;
-        synchronized (object) {
+    public void saveChunks(Iterator<? extends Chunk> chunks) {
+        synchronized (lock) {
             try {
-                while (saveThread != null && !SaveThread.isReady()) {
-                    LOCK.wait();
+                while (thread != null && !thread.isReady()) {
+                    lock.wait();
                 }
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
             }
-            catch (InterruptedException interruptedException) {
-                throw new RuntimeException(interruptedException);
-            }
         }
-        saveThread = new SaveThread(() -> {
-            Object object;
-            while (iterator.hasNext()) {
-                object = (Chunk)iterator.next();
-                if (object == null) continue;
-                this.save((Chunk)object);
+
+        thread = new SaveThread(() -> {
+            while (chunks.hasNext()) {
+                Chunk c = chunks.next();
+
+                if (c != null) {
+                    this.saveChunk(c);
+                }
             }
+
             try {
-                Thread.sleep(5L);
+                Thread.sleep(5); // pls fix save loading bugs
+            } catch (InterruptedException e) {
+                e.printStackTrace();
             }
-            catch (InterruptedException interruptedException) {
-                object = interruptedException;
-                interruptedException.printStackTrace();
-            }
-            object = LOCK;
-            synchronized (object) {
+
+            synchronized (lock) {
                 SaveThread.finish();
-                LOCK.notifyAll();
-                return;
+                lock.notifyAll();
             }
         });
-        saveThread.start();
+
+        thread.start();
     }
 
-    /*
-     * WARNING - Removed try catching itself - possible behaviour change.
-     */
-    public final void save(Iterator<? extends Chunk> iterator, Iterator<Item> iterator2, int n, Pos pos, Pos pos2, long l) {
-        Object object = LOCK;
-        synchronized (object) {
+    public void save(Iterator<? extends Chunk> chunks, Iterator<Item> inventory, int invSize, Pos playerPos, Pos spawnPos, long time) {
+        synchronized (lock) {
             try {
-                while (saveThread != null && !SaveThread.isReady()) {
-                    LOCK.wait();
+                while (thread != null && !thread.isReady()) {
+                    lock.wait();
                 }
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
             }
-            catch (InterruptedException interruptedException) {
-                throw new RuntimeException(interruptedException);
-            }
         }
-        saveThread = new SaveThread(() -> {
-            Object object2;
+
+        thread = new SaveThread(() -> {
             System.out.println("Saving Chunks");
-            while (iterator.hasNext()) {
-                object2 = (Chunk)iterator.next();
-                if (object2 == null) continue;
-                this.save((Chunk)object2);
+
+            while (chunks.hasNext()) {
+                Chunk c = chunks.next();
+
+                if (c != null) {
+                    this.saveChunk(c);
+                }
             }
+
             try {
-                this.saveFile.createNewFile();
-                object2 = new BinaryData();
-                iterator = new DataSection();
-                ((DataSection)((Object)iterator)).writeLong(this.seed);
-                ((DataSection)((Object)iterator)).writeLong(l);
-                ((BinaryData)object2).put("data", (BaseDataSection)((Object)iterator));
-                iterator = new DataSection();
-                ((DataSection)((Object)iterator)).writeDouble(pos.getX());
-                ((DataSection)((Object)iterator)).writeDouble(pos.getY());
-                ((DataSection)((Object)iterator)).writeDouble(pos.getZ());
-                ((DataSection)((Object)iterator)).writeDouble(pos2.getX());
-                ((DataSection)((Object)iterator)).writeDouble(pos2.getY());
-                ((DataSection)((Object)iterator)).writeDouble(pos2.getZ());
-                ((BinaryData)object2).put("player", (BaseDataSection)((Object)iterator));
-                iterator = new DataSection();
-                int n2 = n;
-                Iterator iterator2 = iterator2;
-                DataSection dataSection = iterator;
-                ((DataSection)((Object)iterator)).writeInt(n2);
-                while (iterator2.hasNext()) {
-                    Item item = (Item)iterator2.next();
-                    if (item == null) {
-                        dataSection.writeInt(0);
-                        continue;
-                    }
-                    dataSection.writeInt(item.getTileId());
-                    dataSection.method_243(item.method_259());
-                    dataSection.writeInt(item.getCount());
-                }
-                ((BinaryData)object2).put("playerInventory", (BaseDataSection)((Object)iterator));
-                ((BinaryData)object2).writeGzipped(this.saveFile);
+                this.saveDat.createNewFile();
+                BinaryData data = new BinaryData();
+                DataSection mainData = new DataSection();
+                mainData.writeLong(this.seed);
+                mainData.writeLong(time);
+                data.put("data", mainData);
+
+                // the "self" player, for the client version, is the only player stored
+                DataSection clientPlayerData = new DataSection();
+                clientPlayerData.writeDouble(playerPos.getX());
+                clientPlayerData.writeDouble(playerPos.getY());
+                clientPlayerData.writeDouble(playerPos.getZ());
+                clientPlayerData.writeDouble(spawnPos.getX());
+                clientPlayerData.writeDouble(spawnPos.getY());
+                clientPlayerData.writeDouble(spawnPos.getZ());
+                data.put("player", clientPlayerData);
+
+                DataSection clientPlayerInventory = new DataSection();
+                this.storeInventory(clientPlayerInventory, inventory, invSize);
+                data.put("playerInventory", clientPlayerInventory);
+
+                data.writeGzipped(this.saveDat);
+            } catch (IOException e) {
+                throw new UncheckedIOException("Error writing save data", e);
             }
-            catch (IOException iOException) {
-                throw new UncheckedIOException("Error writing save data", iOException);
-            }
+
             try {
-                Thread.sleep(5L);
+                Thread.sleep(5); // pls fix save loading bugs
+            } catch (InterruptedException e) {
+                e.printStackTrace();
             }
-            catch (InterruptedException interruptedException) {
-                object2 = interruptedException;
-                interruptedException.printStackTrace();
-            }
-            object2 = LOCK;
-            synchronized (object2) {
+
+            synchronized (lock) {
                 SaveThread.finish();
-                LOCK.notifyAll();
-                return;
+                lock.notifyAll();
             }
         });
-        saveThread.start();
+
+        thread.start();
     }
 
-    private static Item[] readInventory(DataSection dataSection) {
-        int n = 0;
-        int n2 = 0;
-        ++n;
-        int n3 = dataSection.readInt(0);
-        Item[] arritem = new Item[n3];
-        while (n3-- > 0) {
-            int n4;
-            if ((n4 = dataSection.readInt(n++)) == 0) {
-                arritem[n2++] = null;
-                continue;
+    private void storeInventory(DataSection playerInventoryData, Iterator<Item> inventory, int size) {
+        playerInventoryData.writeInt(size);
+
+        for (; inventory.hasNext();) {
+            Item item = inventory.next();
+
+            if (item == null) { // for compactness just write 0
+                playerInventoryData.writeInt(0);
+            } else {
+                playerInventoryData.writeInt(item.getTileId());
+                playerInventoryData.method_243(item.method_259());
+                playerInventoryData.writeInt(item.getCount());
             }
-            arritem[n2++] = new Item(n4, dataSection.method_244(n++), dataSection.readInt(n++));
         }
-        return arritem;
     }
 
-    /*
-     * WARNING - Removed try catching itself - possible behaviour change.
-     */
-    public final <T extends Chunk> T loadOrCreate(ChunkView chunkView, int n, int n2, ChunkFactory<T> chunkFactory) {
-        Object object = LOCK;
-        synchronized (object) {
+    private Item[] loadInventory(DataSection playerInventoryData) {
+        int readIndex = 0;
+        int slot = 0;
+        int size = playerInventoryData.readInt(readIndex++);
+        Item[] result = new Item[size];
+
+        while (size --> 0) {
+            int id = playerInventoryData.readInt(readIndex++);
+
+            if (id == 0) {
+                result[slot++] = null;
+            } else {
+                result[slot++] = new Item(id, playerInventoryData.method_244(readIndex++), playerInventoryData.readInt(readIndex++));
+            }
+        }
+
+        return result;
+    }
+
+    public <T extends Chunk> T loadOrCreate(ChunkView parent, int x, int z, ChunkFactory<T> constructor) {
+        synchronized (lock) {
             try {
-                while (saveThread != null && !SaveThread.isReady()) {
-                    LOCK.wait();
+                while (thread != null && !thread.isReady()) {
+                    lock.wait();
                 }
+            } catch (InterruptedException e) {
+                throw new RuntimeException(e);
             }
-            catch (InterruptedException interruptedException) {
-                throw new RuntimeException(interruptedException);
-            }
         }
-        object = new File(this.saveDirectory, "c" + n + "." + n2 + ".gsod");
-        if (((File)object).exists()) {
-            return Chunk.deserialize(chunkView, chunkFactory, BinaryData.readGzipped((File)object));
+
+        File file = new File(this.parentDir, "c" + x + "." + z + ".gsod");
+
+        if (file.exists()) {
+            return Chunk.deserialize(parent, constructor, BinaryData.readGzipped(file));
+        } else {
+            Random genRand = new Random(parent.getSeed() + 134 * x + -529 * z);
+            return ChunkGenerator.generate(constructor, parent, x, z);
         }
-        new Random(chunkView.getSeed() + (long)(n * 134) + (long)(n2 * -529));
-        chunkView.getSeed();
-        return ChunkGenerator.generate(chunkFactory, chunkView, n, n2);
     }
 
-    private void save(Chunk chunk) {
+    private void saveChunk(Chunk chunk) {
+        // only save modified chunks
         if (chunk.method_234()) {
-            File file = new File(this.saveDirectory, "c" + chunk.x + "." + chunk.z + ".gsod");
+            File file = new File(this.parentDir, "c" + chunk.x + "." + chunk.z + ".gsod");
+
             try {
                 file.createNewFile();
-                BinaryData binaryData = new BinaryData();
-                chunk.serialize(binaryData);
-                binaryData.writeGzipped(file);
-                return;
+                BinaryData data = new BinaryData();
+                chunk.serialize(data);
+                data.writeGzipped(file);
+            } catch (IOException e) {
+                throw new UncheckedIOException("Error writing chunk! " + chunk.getPos().toString(), e);
             }
-            catch (IOException iOException) {
-                throw new UncheckedIOException("Error writing chunk! " + chunk.getPos().toString(), iOException);
-            }
         }
     }
-
-    static {
-        LOCK = new Object();
-    }
 }
-
